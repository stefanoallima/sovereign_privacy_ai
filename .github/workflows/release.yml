name: Release

on:
  push:
    tags:
      - 'v*'

permissions:
  contents: write

jobs:
  build:
    strategy:
      fail-fast: false
      matrix:
        include:
          - platform: windows-latest
            target: x86_64-pc-windows-msvc
          - platform: macos-latest
            target: aarch64-apple-darwin
          - platform: macos-latest
            target: x86_64-apple-darwin
    runs-on: ${{ matrix.platform }}

    steps:
      - uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: 22

      - name: Install pnpm
        uses: pnpm/action-setup@v4
        with:
          version: 10

      - name: Install Rust
        uses: dtolnay/rust-toolchain@stable
        with:
          targets: ${{ matrix.target }}

      # Windows: initialise MSVC environment so cmake can detect cl.exe
      - name: Setup MSVC (Windows)
        if: matrix.platform == 'windows-latest'
        uses: ilammy/msvc-dev-cmd@v1

      - name: Install dependencies (macOS)
        if: runner.os == 'macOS'
        run: |
          brew install cmake llvm
          LLVM_PATH=$(brew --prefix llvm)
          echo "$LLVM_PATH/bin" >> $GITHUB_PATH
          echo "LIBCLANG_PATH=$LLVM_PATH/lib" >> $GITHUB_ENV

          if [[ "${{ matrix.target }}" == "aarch64-apple-darwin" ]]; then
            # Apple Silicon minimum is macOS 11.0.
            # cmake crate 0.1.57 emits --target=arm64-apple-macosx (unversioned); with Apple
            # clang 16+ that unversioned triple overrides -mmacosx-version-min and leaves OS
            # as "unknown", making std::filesystem appear unavailable.
            # Fix: append a versioned triple via global CFLAGS/CXXFLAGS.
            # Global CFLAGS is safe here because the runner IS arm64 (host == target arch),
            # so host-compiled build scripts and proc-macros also compile as arm64 correctly.
            echo "MACOSX_DEPLOYMENT_TARGET=11.0" >> $GITHUB_ENV
            echo "CFLAGS=--target=arm64-apple-macos11.0 -mmacosx-version-min=11.0" >> $GITHUB_ENV
            echo "CXXFLAGS=--target=arm64-apple-macos11.0 -mmacosx-version-min=11.0" >> $GITHUB_ENV
          else
            # Intel x86_64 cross-compile from an ARM64 runner.
            # llama.cpp's ggml-backend-reg.cpp uses std::filesystem which requires macOS 10.15+.
            # clang auto-adds --target=x86_64-apple-macosx (unversioned) when cross-compiling,
            # which makes the OS version "unknown" and std::filesystem appear unavailable.
            # Fix: inject the versioned triple via target-specific env vars only (to avoid
            # contaminating host arm64 builds for proc-macros / build scripts).
            #
            #  • CFLAGS_x86_64_apple_darwin  – picked up by cc crate for cc-based crates (ring,
            #                                  zstd, onig, etc.); does NOT affect host builds.
            #  • CMAKE_C/CXX_FLAGS           – cmake crate reads these and passes them as
            #                                  -DCMAKE_C_FLAGS to cmake (llama-cpp-sys-2).
            TARGET_FLAGS="-target x86_64-apple-macos10.15 -mmacosx-version-min=10.15"
            echo "MACOSX_DEPLOYMENT_TARGET=10.15" >> $GITHUB_ENV
            echo "CFLAGS_x86_64_apple_darwin=$TARGET_FLAGS" >> $GITHUB_ENV
            echo "CXXFLAGS_x86_64_apple_darwin=$TARGET_FLAGS" >> $GITHUB_ENV
            echo "CMAKE_C_FLAGS=$TARGET_FLAGS" >> $GITHUB_ENV
            echo "CMAKE_CXX_FLAGS=$TARGET_FLAGS" >> $GITHUB_ENV
          fi

          # Use a short target dir to keep paths manageable
          echo "CARGO_TARGET_DIR=/tmp/ct" >> $GITHUB_ENV

      - name: Install dependencies (Windows)
        if: matrix.platform == 'windows-latest'
        run: |
          # cmake is pre-installed on the runner; only install LLVM for bindgen
          choco install llvm -y
          echo "C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_PATH -Encoding utf8 -Append
          echo "LIBCLANG_PATH=C:\Program Files\LLVM\bin" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append
          # Use a short target dir to avoid Windows MAX_PATH issues with llama.cpp cmake temp files
          echo "CARGO_TARGET_DIR=D:\ct" | Out-File -FilePath $env:GITHUB_ENV -Encoding utf8 -Append

      # Bundle ONNX Runtime 1.20.1 so GLiNER PII detection works on user machines
      - name: Bundle ONNX Runtime (macOS)
        if: runner.os == 'macOS'
        run: |
          mkdir -p apps/desktop/src-tauri/onnxruntime
          curl -L "https://github.com/microsoft/onnxruntime/releases/download/v1.20.1/onnxruntime-osx-arm64-1.20.1.tgz" -o /tmp/ort.tgz
          tar -xzf /tmp/ort.tgz -C /tmp/
          # Copy the versioned dylib, rename to unversioned so ORT_DYLIB_PATH is stable
          cp /tmp/onnxruntime-osx-arm64-1.20.1/lib/libonnxruntime.1.20.1.dylib \
             apps/desktop/src-tauri/onnxruntime/libonnxruntime.dylib

      - name: Bundle ONNX Runtime (Windows)
        if: matrix.platform == 'windows-latest'
        run: |
          New-Item -ItemType Directory -Force -Path "apps/desktop/src-tauri/onnxruntime"
          Invoke-WebRequest -Uri "https://github.com/microsoft/onnxruntime/releases/download/v1.20.1/onnxruntime-win-x64-1.20.1.zip" -OutFile "$env:TEMP\ort.zip"
          Expand-Archive -Path "$env:TEMP\ort.zip" -DestinationPath "$env:TEMP\ort"
          Copy-Item "$env:TEMP\ort\onnxruntime-win-x64-1.20.1\lib\onnxruntime.dll" "apps/desktop/src-tauri/onnxruntime/"
          Copy-Item "$env:TEMP\ort\onnxruntime-win-x64-1.20.1\lib\onnxruntime_providers_shared.dll" "apps/desktop/src-tauri/onnxruntime/"

      - name: Install frontend dependencies
        working-directory: apps/desktop
        run: pnpm install

      - name: Set version from tag
        shell: bash
        run: |
          VERSION="${{ github.ref_name }}"
          VERSION="${VERSION#v}"  # strip leading 'v'
          # Patch version into tauri.conf.json so installer filename matches the tag.
          # Use perl instead of sed -i because BSD sed (macOS) requires 'sed -i ""' while
          # GNU sed (Linux/Windows) requires 'sed -i'. perl -i works on all platforms.
          perl -i -pe "s/\"version\": \"[^\"]*\"/\"version\": \"$VERSION\"/" apps/desktop/src-tauri/tauri.conf.json
          echo "Building version $VERSION"

      - name: Build Tauri app
        uses: tauri-apps/tauri-action@v0
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          # MACOSX_DEPLOYMENT_TARGET is set per-target in "Install dependencies (macOS)":
          #   aarch64 → 11.0,  x86_64 → 10.13  (do NOT hardcode it here)
          # Signing key for auto-updater (set in GitHub repo secrets)
          TAURI_SIGNING_PRIVATE_KEY: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY }}
          TAURI_SIGNING_PRIVATE_KEY_PASSWORD: ${{ secrets.TAURI_SIGNING_PRIVATE_KEY_PASSWORD }}
        with:
          projectPath: apps/desktop
          tagName: ${{ github.ref_name }}
          releaseName: 'Sovereign AI ${{ github.ref_name }}'
          releaseBody: |
            Download Sovereign AI for your platform:
            - **Windows**: `.exe` installer
            - **macOS (Apple Silicon)**: `.dmg` for M1/M2/M3
            - **macOS (Intel)**: `.dmg` for Intel Macs
          releaseDraft: false
          prerelease: false
          updaterJsonKeepUniversal: true
          args: --target ${{ matrix.target }}
